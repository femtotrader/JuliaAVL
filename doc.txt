
SortDict is currently implemented as an AVL tree. 


SortDict(ks, vs)
SortDict(K, V)
SortDict(d :: Dict)
SortDict(a :: Tuple[])

	Creates a new SortDict from an vector of keys and a corresponding vector of values.

	example:

	sd = SortDict(
		["One", "Two", "Two and a half"], 
		[1.0, 2.0, 2.5]
	)

	The isless comarator will be used, unless you specify your own as a third argument.
	The keys must be sorted with no equal keys (according to the compare function used)

	SortDict(K, V) creates a new empty SortDict for keys of type K, values of type V
	Values can then be assigned to keys like with a Dict(): sd[""] = "mama"

	You can also make SortDicts out of Dicts or arrays of key, value tuples
	
eltype(sd) 

	returns tuple of types : (key_type, value_type)

	
isempty (sd), length(sd) or numel(sd), isequal(sd1, sd2)
	
	Obvious functions

	
copy(sd) 
	
	Returns a shallow copy of a tree.

	
deeper_copy(sd)

	Returns a not-so shallow copy of a tree.
	There is no way to guarantee true deep copy, since it all depends on the copy functions of the keys and values.

	
flatten(sd)
keys(sd)
values(sd)

	flatten returns tuple of arrays: (keys, values)

	
del_all(sd)

	Clear the SortDict

	
map(fn, sd), map!(fn, sd)

	Applies fn to all values in sd. 
	
	
Goright
Goleft
Gorightkv
Goleftkv
	
	These are iterator constructors.
	You can iterate over a SortDict directly or get special iterators that begins at given
	keys and go left or right. These can of course be combined with Julia's generic iterator functions.
	
	examples:
	
		sd = SortDict([1,2,3,4], [1.0, 2.0, 3.0, 4.0])

		sum(sd) 	=> 10.0
	
	sum(sd) is the same as sum(Goright(sd))
	
		reduce ((a,b) -> (2a+b),2.0, (Goleft(sd)))	=> 81.0

		reduce ((a,b) -> (2a+b),2.0, (Goright(sd)))	=> 58.0
		
		sum(Goright(sd, 2))
		
		for x in Goright(sd,2)
			print(x, " ")		=> 2.0 3.0 4.0 
		end

	The versions with kv suffix returns (key, value) tuples instead of just values:
	
		for x in Goleftkv(sd,2)
			print(x, " ")		=> (2,2.0) (1, 1.0) 
		end
	
	Time complexities for iterators are O(m + log n), where n is the size of the SortDict, m the length of the iteration run.

	
split!(sd, key)

	Returns two SortDicts sd1 and sd2.
	
	sd1 contains all keys up to but not including 'key', while sd2 contains the rest.
	
	Runs in O(log n).
	

	
join!(sd1, sd2)

	Appends sd2 to the right of sd1. Note that the first element of sd2 must be strictly greater than
	the last element of sd1, otherwise an exception is thrown. Sd2 is always cleared when calling join!.
	
	Runs in O(log n).
	

first(sd)
last(sd)
first(sd, m)
last(sd, m)

	Returns the first or last element(s) of sd. Runs in O((log n) + m)

	
valid(sd)
	
	Checks that sd is actually a valid SortDict. Returns false if the datastructure is somehow corrupted.
	Runs in linear time.

	
shift(sd) or del_first(sd)
pop(sd) or del_last(sd)

	Destructive functions that removes and returns values at the extreme ends of a non-empty SortDict.
	Runs in log n

	
del(sd, key)
del(sd, key, default)

	Returns the deleted (key, value) tuple, which must exist, unless a default is given. 
	Runs in O(log n)
	

has(sd, key) or Contains(sd, key)

	Returns Bool. Runs in O(log n)

	
get(sd, key, default)

	Returns item, if it exist, else returns default. Runs in O(log n)

	
rank(sd, key)

	Returns the position of key in the SortDict
	example:
	
	sd = SortDict(["Aardvark", "baa", "cab", "dab"], [8,3,3,3])

	rank(sd, "Aardvark") 	=> 1
	
	Note that ranks are 1-based, in accordance with Julia arrays.
	Runs in O(log n)
	
	
select(sd, r)

	Returns the (key, value) tuple associated with rank r
	
	Using the above sd, select(sd, 3) would return ("cab", 3). 

	Note that select is 1-based, in accordance with Julia arrays.
	Runs in O(log n)
	
	
before(sd, key)
after(sd, key)

	returns the (key, value) tuple that comes just before or just after key.
	An exception is thrown if there is nothing in the SortDict before or after the key.
	However, the key need not exist, so the following works:
	
	sd = SortDict(["Aardvark", "baa", "cab", "dab"], [8,3,3,3])
	
	before(sd, "zebra") 	=> ("dab", 3)

	Runs in O(log n)
	
	
union(sd1, sd2)
union!(sd1, sd2)

	Returs the union of the two SortDicts. Compare functions must be identical.
	The values from sd2 are used whenever equal keys are encountered.  
	The destructive variant may be faster when the sets are of different size.
	Runs in O(n).
	
	
intersect(sd1, sd2)

	Returns the common elements of sd1 and sd2. Intersections are calculated faster when one 
	of the SortDicts is much smaller than the other.
	Runs in O(n).
	
	
difference(sd1, sd2)

	Returns the elements sd1 has, that sd2 doesn't have. Sometimes faster if one 
	of the SortDicts is much smaller than the other.
	Runs in O(n).
